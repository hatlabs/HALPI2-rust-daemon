#!/usr/bin/env bash
#
# usage: ./run command [argument ...]
#
# Commands used during development / CI.
# Also, executable documentation for project dev practices.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

################################################################################
# Core Development Commands

function build {
  #@ Build all workspace members (debug by default)
  #@ Usage: build [--release]
  #@ Category: Core Development
  cargo build $@
}

function build:daemon {
  #@ Build the halpid daemon
  #@ Usage: build:daemon [--release]
  #@ Category: Core Development
  cargo build -p halpid $@
}

function build:cli {
  #@ Build the halpi CLI
  #@ Usage: build:cli [--release]
  #@ Category: Core Development
  cargo build -p halpi $@
}

function clean {
  #@ Clean all build artifacts
  #@ Category: Core Development
  cargo clean $@
}

function check {
  #@ Run cargo check and clippy
  #@ Category: Core Development
  cargo check --all-targets
  cargo clippy --all-targets -- -D warnings
}

function fmt {
  #@ Format code with rustfmt
  #@ Category: Core Development
  cargo fmt --all
}

function fmt:check {
  #@ Check code formatting without making changes
  #@ Category: Core Development
  cargo fmt --all -- --check
}

################################################################################
# Cross-Compilation Commands

function build:cross {
  #@ Build for ARM64 Linux using cross
  #@ Usage: build:cross [--release]
  #@ Category: Cross-Compilation
  if ! command -v cross &> /dev/null; then
    echo "Error: 'cross' not found. Run './run cross:setup' first."
    exit 1
  fi

  cross build --target aarch64-unknown-linux-musl $@
}

function cross:setup {
  #@ Install cross-compilation tools
  #@ Category: Cross-Compilation
  cargo install cross
  echo "‚úÖ cross installed successfully"
}

################################################################################
# Testing Commands

function test {
  #@ Run all tests
  #@ Category: Testing
  cargo test $@
}

function test:unit {
  #@ Run unit tests only
  #@ Category: Testing
  cargo test --lib $@
}

function test:integration {
  #@ Run integration tests only
  #@ Category: Testing
  cargo test --test '*' $@
}

function test:coverage {
  #@ Run tests with coverage (requires cargo-tarpaulin)
  #@ Category: Testing
  if ! command -v cargo-tarpaulin &> /dev/null; then
    echo "Installing cargo-tarpaulin..."
    cargo install cargo-tarpaulin
  fi

  cargo tarpaulin --out Html --output-dir target/coverage
  echo "‚úÖ Coverage report generated in target/coverage/"
}

################################################################################
# Docker-based Build Commands (for macOS/non-Linux development)

function build:docker {
  #@ Build in Docker container (automatic Linux environment)
  #@ Category: Docker Build
  local build_args="$@"

  echo "üèóÔ∏è  Building in Docker container..."

  # Detect host architecture for platform selection
  local arch=$(uname -m)
  local platform=""
  case "$arch" in
    arm64|aarch64) platform="linux/arm64" ;;
    x86_64|amd64) platform="linux/amd64" ;;
    *) platform="linux/amd64" ;;  # Default to amd64 if unknown
  esac

  docker run --rm \
    --platform "$platform" \
    -v "$(pwd):/workspace" \
    -w /workspace \
    mcr.microsoft.com/devcontainers/rust:1-bookworm \
    bash -c "
      set -e
      echo 'üì¶ Updating Rust toolchain...'
      rustup update stable > /dev/null 2>&1
      rustup default stable > /dev/null 2>&1
      echo 'üì¶ Installing ARM64 target...'
      rustup target add aarch64-unknown-linux-musl
      echo 'üî® Running cargo build $build_args...'
      cargo build $build_args
      echo '‚úÖ Build complete!'
    "

  if [ $? -eq 0 ]; then
    echo "‚úÖ Build successful in Docker container"
  else
    echo "‚ùå Build failed"
    return 1
  fi
}

function build:docker:cross {
  #@ Build for ARM64 in Docker container using cross
  #@ Category: Docker Build
  local build_args="$@"

  echo "üèóÔ∏è  Cross-compiling for ARM64 in Docker container..."

  # Detect host architecture for platform selection
  local arch=$(uname -m)
  local platform=""
  local cache_suffix=""
  case "$arch" in
    arm64|aarch64)
      platform="linux/arm64"
      cache_suffix="arm64"
      ;;
    x86_64|amd64)
      platform="linux/amd64"
      cache_suffix="amd64"
      ;;
    *)
      platform="linux/amd64"
      cache_suffix="amd64"
      ;;
  esac

  # Create architecture-specific Docker volume for cargo cache
  local cache_volume="halpi2-cargo-cache-${cache_suffix}"
  docker volume create "$cache_volume" > /dev/null 2>&1 || true

  docker run --rm \
    --platform "$platform" \
    -v "$(pwd):/workspace" \
    -w /workspace \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v "${cache_volume}:/cargo-cache" \
    mcr.microsoft.com/devcontainers/rust:1-bookworm \
    bash -c "
      set -e
      echo 'üì¶ Updating Rust toolchain...'
      rustup update stable > /dev/null 2>&1
      rustup default stable > /dev/null 2>&1

      echo 'üì¶ Installing Docker CLI for cross...'
      apt-get update -qq && apt-get install -y -qq docker.io > /dev/null 2>&1

      echo 'üì¶ Installing cross-compilation tools...'
      rustup target add aarch64-unknown-linux-musl > /dev/null 2>&1

      # Check if cross is cached, otherwise install it
      if [ -f /cargo-cache/bin/cross ]; then
        echo '   Using cached cross binary'
        cp /cargo-cache/bin/cross /usr/local/cargo/bin/
        chmod +x /usr/local/cargo/bin/cross
      else
        echo '   Installing cross (this will be cached)...'
        cargo install cross --locked 2>&1 | grep -E '(Installing|Installed)' || true
        mkdir -p /cargo-cache/bin
        cp /usr/local/cargo/bin/cross /cargo-cache/bin/ 2>/dev/null || true
      fi

      echo 'üî® Running cross build for ARM64...'
      cross build --target aarch64-unknown-linux-musl $build_args
      echo '‚úÖ Cross-compilation complete!'
    "

  if [ $? -eq 0 ]; then
    echo "‚úÖ ARM64 build successful"
    echo "   Binaries in: target/aarch64-unknown-linux-musl/"
  else
    echo "‚ùå Build failed"
    return 1
  fi
}

function package:deb:docker {
  #@ Build Debian package for ARM64 in Docker container
  #@ Category: Docker Build

  echo "üèóÔ∏è  Building Debian package for ARM64 in Docker container..."

  # Detect host architecture for platform selection
  local arch=$(uname -m)
  local platform=""
  local cache_suffix=""
  case "$arch" in
    arm64|aarch64)
      platform="linux/arm64"
      cache_suffix="arm64"
      ;;
    x86_64|amd64)
      platform="linux/amd64"
      cache_suffix="amd64"
      ;;
    *)
      platform="linux/amd64"
      cache_suffix="amd64"
      ;;
  esac

  # Create architecture-specific Docker volume for cargo cache
  local cache_volume="halpi2-cargo-cache-${cache_suffix}"
  docker volume create "$cache_volume" > /dev/null 2>&1 || true

  docker run --rm \
    --platform "$platform" \
    -v "$(pwd):/workspace" \
    -w /workspace \
    -v "${cache_volume}:/cargo-cache" \
    mcr.microsoft.com/devcontainers/rust:1-bookworm \
    bash -c "
      set -e
      echo 'üì¶ Updating Rust toolchain...'
      rustup update stable > /dev/null 2>&1
      rustup default stable > /dev/null 2>&1

      echo 'üì¶ Installing ARM64 cross-compilation toolchain...'
      apt-get update -qq && apt-get install -y -qq gcc-aarch64-linux-gnu > /dev/null 2>&1

      echo 'üì¶ Installing build tools...'
      rustup target add aarch64-unknown-linux-musl

      # Check if cargo-deb is cached, otherwise install it
      if [ -f /cargo-cache/bin/cargo-deb ]; then
        echo '   Using cached cargo-deb binary'
        cp /cargo-cache/bin/cargo-deb /usr/local/cargo/bin/
        chmod +x /usr/local/cargo/bin/cargo-deb
      else
        echo '   Installing cargo-deb (this will be cached)...'
        cargo install cargo-deb --locked 2>&1 | grep -E '(Installing|Installed)' || true
        mkdir -p /cargo-cache/bin
        cp /usr/local/cargo/bin/cargo-deb /cargo-cache/bin/ 2>/dev/null || true
      fi

      echo 'üî® Building release binary for ARM64...'
      CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc \
      cargo build --target aarch64-unknown-linux-musl --release

      echo 'üì¶ Creating Debian package...'
      cargo deb -p halpid --target aarch64-unknown-linux-musl --no-build

      echo '‚úÖ Debian package built!'
    "

  if [ $? -eq 0 ]; then
    echo ""
    echo "‚úÖ Debian package built successfully!"
    local deb_file=$(ls -t target/aarch64-unknown-linux-musl/debian/*.deb 2>/dev/null | head -1)
    if [ -n "$deb_file" ]; then
      echo "   Package: $deb_file"
      ls -lh "$deb_file"
    fi
  else
    echo ""
    echo "‚ùå Package build failed"
    return 1
  fi
}

################################################################################
# Package Management Commands

function package:deb {
  #@ Build Debian package (native)
  #@ Category: Package Management
  echo "üèóÔ∏è Building Debian package..."

  if ! command -v cargo-deb &> /dev/null; then
    echo "Installing cargo-deb..."
    cargo install cargo-deb
  fi

  cargo deb -p halpid
  echo "‚úÖ Debian package built successfully"
}

function package:deb:cross {
  #@ Build Debian package for ARM64 using cross
  #@ Category: Package Management
  echo "üèóÔ∏è Building ARM64 Debian package..."

  # First build release binary for ARM64
  build:cross --release

  # Then build package
  if ! command -v cargo-deb &> /dev/null; then
    echo "Installing cargo-deb..."
    cargo install cargo-deb
  fi

  cargo deb -p halpid --target aarch64-unknown-linux-musl --no-build
  echo "‚úÖ ARM64 Debian package built successfully"
}

################################################################################
# Development Utilities

function dev:daemon {
  #@ Run daemon in development mode
  #@ Category: Development
  cargo run -p halpid
}

function dev:clean:all {
  #@ Deep clean (cargo + artifacts + packages)
  #@ Category: Development
  clean
  rm -rf target/debian
  rm -rf target/coverage
  echo "‚úÖ Deep clean complete"
}

function dev:version:bump {
  #@ Bump version to specified version
  #@ Usage: dev:version:bump <version>
  #@ Category: Development
  local new_version=$1

  if [ -z "$new_version" ]; then
    echo "Error: Version required. Usage: ./run dev:version:bump <version>"
    exit 1
  fi

  echo "Bumping version to $new_version..."
  # Portable sed in-place replacement (works on GNU and BSD)
  sed "s/^version = \".*\"/version = \"$new_version\"/" Cargo.toml > Cargo.toml.tmp && mv Cargo.toml.tmp Cargo.toml

  echo "‚úÖ Version bumped to $new_version in Cargo.toml"
  echo "Run 'cargo update' to update Cargo.lock"
}

function dev:version:show {
  #@ Show current version
  #@ Category: Development
  grep -m1 '^version = ' Cargo.toml | cut -d'"' -f2
}

################################################################################
# Release/Version Commands

function release:version {
  #@ Get current version
  #@ Category: Release/Version
  dev:version:show
}

function release:build {
  #@ Build release artifacts for ARM64
  #@ Category: Release/Version
  echo "üèóÔ∏è Building release artifacts for ARM64..."
  build:cross --release
  echo "‚úÖ Release artifacts built in target/aarch64-unknown-linux-musl/release/"
}

################################################################################
# CI/CD Commands

function ci:check {
  #@ Run CI verification checks
  #@ Category: CI/CD
  echo "üîç Running CI checks..."
  check
  fmt:check
  test
  echo "‚úÖ All CI checks passed"
}

function ci:build {
  #@ Full CI build pipeline
  #@ Category: CI/CD
  echo "üöÄ Running full CI build pipeline..."
  ci:check
  build --release
  echo "‚úÖ CI build complete"
}

################################################################################
# Help System

function help {
  #@ Show this help message
  #@ Category: Help
  echo "HALPI2 Rust Daemon Development Commands"
  echo
  echo "Usage: ./run <command> [arguments]"
  echo

  # Extract categories and commands
  declare -A categories
  while IFS= read -r line; do
    if [[ $line =~ ^function\ ([a-zA-Z0-9_:]+) ]]; then
      func_name="${BASH_REMATCH[1]}"

      # Read the next lines for documentation
      desc=""
      usage=""
      category="General"

      while IFS= read -r doc_line; do
        if [[ $doc_line =~ ^[[:space:]]*#@[[:space:]]+(.*) ]]; then
          content="${BASH_REMATCH[1]}"
          if [[ $content =~ ^Usage:[[:space:]]+(.*) ]]; then
            usage="${BASH_REMATCH[1]}"
          elif [[ $content =~ ^Category:[[:space:]]+(.*) ]]; then
            category="${BASH_REMATCH[1]}"
          else
            desc="$content"
          fi
        else
          break
        fi
      done

      # Store command in category
      if [ -n "$desc" ]; then
        cmd_info="  $func_name"
        [ -n "$usage" ] && cmd_info="$cmd_info [$usage]"
        cmd_info="$cmd_info - $desc"
        categories[$category]+="$cmd_info"$'\n'
      fi
    fi
  done < "$0"

  # Print categories in order
  for category in "Core Development" "Cross-Compilation" "Testing" "Package Management" "Development" "Release/Version" "CI/CD" "Help"; do
    if [ -n "${categories[$category]}" ]; then
      echo "$category:"
      echo "${categories[$category]}"
    fi
  done
}

################################################################################
# Main dispatcher

# If no arguments provided, show help
if [ $# -eq 0 ]; then
  help
  exit 0
fi

# Get the command name
cmd=$1
shift

# Replace - with : for command names (allows both ./run build:daemon and ./run build-daemon)
cmd=${cmd//-/:}

# Check if function exists
if declare -f "$cmd" > /dev/null; then
  # Run the command with timing
  TIMEFORMAT=$'\nTask completed in %3lR'
  time "$cmd" "$@"
else
  echo "Error: Unknown command '$cmd'"
  echo
  echo "Run './run help' to see available commands"
  exit 1
fi
